class GaussFitResult:
    """
    Notes by ATM
    This packages the least squares fit results, dx & dz values,
    and provides a way of returning the A, x, y, z, wzy, wx, background values.
    This is the last step of the code! (The Result!)

    x, y, wxy will be automatically normalized by dx if not "realspace."
    I think this means that if the user specifies the pixel microns, then it uses
    those coordinates.

    Similar for z, wz, except using dz.

    FitModelWeighted is used to get the fit results, which are passed into here.
    FitModelWeighted in turn calls optimize.leastsq().
    Since that function passes back a list of results, it is convenient to have
    a way of referring to them by name, rather than some arbitrary position.

    Had I written this, I would have been more likely to package the results in just a dict,
    and then pass along dx, dz as needed to calculate the normalized values.

    In fact, if many PSF fits are expected, then it might even be more efficient to pack these
    into a dict of lists (one list per parameter), which could then be converted to a dataframe
    (allowing for vectorized operations).

    I think wxy and wz are _w_eights?

    fitErr is the "error" of the fit (and not some sort of computational error).

    A is the amplitude (max - min).

    slicekey is some sort of way of storing a zslice, yslice, xslice information.

    resultCode is generated by optimize().

    What is background? f_Gauss3d says that it's a 3D PSF function with constant background.
    I guess this is because it needs to evaluate to ~= 0 after background subtraction.
    """

    def __init__(self, fitResults, dx, dz, slicekey=None, resultCode=None, fitErr=None):
        self.fitResults = fitResults
        self.dx = dx
        self.dz = dz
        self.slicekey = slicekey
        self.resultCode = resultCode
        self.fitErr = fitErr

    def A(self):
        return self.fitResults[0]

    def x(self, realspace=True):
        r = self.fitResults[1]
        return r if realspace else r / self.dx

    def y(self, realspace=True):
        r = self.fitResults[2]
        return r if realspace else r / self.dx

    def z(self, realspace=True):
        r = self.fitResults[3]
        return r if realspace else r / self.dz

    def wxy(self, realspace=True):
        r = self.fitResults[4]
        return r if realspace else r / self.dx

    def wz(self, realspace=True):
        r = self.fitResults[5]
        return r if realspace else r / self.dz

    def background(self):
        return self.fitResults[6]


class GaussFitter3D(object):
    """
    Notes by ATM

    To follow the code, it's easiest to start here!

    Giving default values for dz & dx is a bit dangerous, as it wasn't obvious to me at first
    that I needed to specify these values! If they aren't given defaults, then it forces
    the user to think carefully about what they should be. Worst case, they can be set to 1.

    What are 0.17 & 0.37... where do those numbers come from?

    How is slicekey stored? Is it just 3 ranges, 1 for each dimension?
    """

    def __init__(self, data, dz=1, dx=1, wx=0.17, wz=0.37):
        self.data = data
        self.dz = dz
        self.dx = dx
        self.wx = wx
        self.wz = wz

    def __getitem__(self, key):
        """return gaussian fit of a 3D roi defined by a 3-tuple of slices"""
        zslice, yslice, xslice = key
        # cut region out of data stack
        dataROI = self.data[zslice, yslice, xslice].astype("f")

        # generate grid to evaluate function on
        Z, Y, X = np.mgrid[zslice, yslice, xslice]

        # adjust for voxel size
        X = self.dx * X
        Y = self.dx * Y
        Z = self.dz * Z

        # amplitude
        A = dataROI.max() - dataROI.min()

        # subtract background
        drc = dataROI - dataROI.min()

        drc = np.maximum(drc - drc.max() / 2, 0)

        # normalize sum to 1
        drc = drc / drc.sum()

        x0 = (X * drc).sum()
        y0 = (Y * drc).sum()
        z0 = (Z * drc).sum()

        startParameters = [3 * A, x0, y0, z0, self.wx, self.wz, dataROI.min()]

        # NOTE Does this estimate the amount of noise from the camera?
        sigma = calculate_sigma(
            electrons_per_ADU=0.5,
            TrueEMGain=1,
            NoiseFactor=1,
            ReadNoise=1.2,
            dataROI=dataROI,
        )

        # Calculate the fit & some other information:
        # covariance matrix, infodict, mesgl, resCode
        (res1, cov_x, infodict, mesg1, resCode) = FitModelWeighted(
            f_Gauss3d, startParameters, dataROI, sigma, X, Y, Z
        )
        # misfit = (infodict['fvec']**2).sum()  # nfev is the number of function calls

        # Also calculate the "errors" of the fit
        fitErrors = None
        try:
            fitErrors = np.sqrt(
                np.diag(cov_x)
                * (infodict["fvec"] * infodict["fvec"]).sum()
                / (dataROI.size - len(res1))
            )
        except Exception:
            pass

        # Package the results into a GaussFitResult object & return
        return GaussFitResult(res1, self.dx, self.dz, key, resCode, fitErrors)
